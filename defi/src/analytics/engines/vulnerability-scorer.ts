/**
 * Vulnerability Scorer
 * Story: 4.1.2 - MEV Protection Insights
 * 
 * Calculates overall transaction vulnerability score
 * 
 * Scoring Method:
 * - Weighted average of sandwich (50%), frontrun (30%), backrun (20%)
 * - Risk categorization: low (0-30), medium (31-60), high (61-80), critical (81-100)
 * - Confidence scoring based on data quality
 * 
 * Output: Vulnerability assessment with recommendations
 */

import { SandwichRiskCalculator, SandwichRiskInput, SandwichRiskResult } from './sandwich-risk-calculator';
import { FrontrunRiskCalculator, FrontrunRiskInput, FrontrunRiskResult } from './frontrun-risk-calculator';
import { BackrunRiskCalculator, BackrunRiskInput, BackrunRiskResult } from './backrun-risk-calculator';

// ============================================================================
// Types
// ============================================================================

export interface VulnerabilityInput {
  // Transaction details
  amount_in_usd: number;
  tx_value_usd: number;
  slippage_tolerance_pct: number;
  expected_price_impact_pct: number;
  
  // Pool details
  pool_liquidity_usd: number;
  pool_volume_24h_usd: number;
  
  // Network details
  gas_price_gwei: number;
  network_avg_gas_price_gwei: number;
  mempool_pending_txs: number;
  block_time_seconds: number;
  
  // Transaction characteristics
  is_time_sensitive: boolean;
  use_private_mempool?: boolean;
  
  // Optional
  chain_id?: string;
}

export interface VulnerabilityScore {
  overall_score: number;           // 0-100
  risk_category: 'low' | 'medium' | 'high' | 'critical';
  confidence_score: number;        // 0-100
  
  // Individual risk scores
  sandwich_risk: number;           // 0-100
  frontrun_risk: number;           // 0-100
  backrun_risk: number;            // 0-100
  
  // Risk breakdowns
  sandwich_details: SandwichRiskResult;
  frontrun_details: FrontrunRiskResult;
  backrun_details: BackrunRiskResult;
  
  // Recommendations
  recommendations: string[];
  explanation: string;
}

// ============================================================================
// Vulnerability Scorer
// ============================================================================

export class VulnerabilityScorer {
  private static instance: VulnerabilityScorer;

  // Risk weights (total = 100%)
  private readonly WEIGHTS = {
    sandwich: 0.50,    // 50%
    frontrun: 0.30,    // 30%
    backrun: 0.20,     // 20%
  };

  // Confidence factors
  private readonly CONFIDENCE_FACTORS = {
    has_pool_data: 20,           // 20 points if pool data available
    has_network_data: 20,        // 20 points if network data available
    has_price_impact: 20,        // 20 points if price impact calculated
    has_mempool_data: 20,        // 20 points if mempool data available
    data_freshness: 20,          // 20 points for fresh data
  };

  private sandwichCalculator: SandwichRiskCalculator;
  private frontrunCalculator: FrontrunRiskCalculator;
  private backrunCalculator: BackrunRiskCalculator;

  private constructor() {
    this.sandwichCalculator = SandwichRiskCalculator.getInstance();
    this.frontrunCalculator = FrontrunRiskCalculator.getInstance();
    this.backrunCalculator = BackrunRiskCalculator.getInstance();
  }

  public static getInstance(): VulnerabilityScorer {
    if (!VulnerabilityScorer.instance) {
      VulnerabilityScorer.instance = new VulnerabilityScorer();
    }
    return VulnerabilityScorer.instance;
  }

  /**
   * Calculate overall vulnerability score
   */
  public calculateVulnerability(input: VulnerabilityInput): VulnerabilityScore {
    // Calculate individual risk scores
    const sandwichResult = this.calculateSandwichRisk(input);
    const frontrunResult = this.calculateFrontrunRisk(input);
    const backrunResult = this.calculateBackrunRisk(input);

    // Calculate weighted overall score
    const overallScore = 
      sandwichResult.overall_risk * this.WEIGHTS.sandwich +
      frontrunResult.overall_risk * this.WEIGHTS.frontrun +
      backrunResult.overall_risk * this.WEIGHTS.backrun;

    // Determine risk category
    const riskCategory = this.getRiskCategory(overallScore);

    // Calculate confidence score
    const confidenceScore = this.calculateConfidence(input);

    // Generate recommendations
    const recommendations = this.generateRecommendations(
      overallScore,
      sandwichResult,
      frontrunResult,
      backrunResult
    );

    // Generate explanation
    const explanation = this.generateExplanation(
      overallScore,
      riskCategory,
      sandwichResult,
      frontrunResult,
      backrunResult
    );

    return {
      overall_score: Math.round(overallScore * 100) / 100,
      risk_category: riskCategory,
      confidence_score: Math.round(confidenceScore),
      sandwich_risk: Math.round(sandwichResult.overall_risk * 100) / 100,
      frontrun_risk: Math.round(frontrunResult.overall_risk * 100) / 100,
      backrun_risk: Math.round(backrunResult.overall_risk * 100) / 100,
      sandwich_details: sandwichResult,
      frontrun_details: frontrunResult,
      backrun_details: backrunResult,
      recommendations,
      explanation,
    };
  }

  /**
   * Calculate sandwich risk
   */
  private calculateSandwichRisk(input: VulnerabilityInput): SandwichRiskResult {
    const sandwichInput: SandwichRiskInput = {
      amount_in_usd: input.amount_in_usd,
      slippage_tolerance_pct: input.slippage_tolerance_pct,
      pool_liquidity_usd: input.pool_liquidity_usd,
      pool_volume_24h_usd: input.pool_volume_24h_usd,
      gas_price_gwei: input.gas_price_gwei,
      mempool_pending_txs: input.mempool_pending_txs,
      chain_id: input.chain_id,
    };

    return this.sandwichCalculator.calculateRisk(sandwichInput);
  }

  /**
   * Calculate frontrun risk
   */
  private calculateFrontrunRisk(input: VulnerabilityInput): FrontrunRiskResult {
    const frontrunInput: FrontrunRiskInput = {
      tx_value_usd: input.tx_value_usd,
      gas_price_gwei: input.gas_price_gwei,
      is_time_sensitive: input.is_time_sensitive,
      network_avg_gas_price_gwei: input.network_avg_gas_price_gwei,
      mempool_pending_txs: input.mempool_pending_txs,
      block_time_seconds: input.block_time_seconds,
      chain_id: input.chain_id,
      use_private_mempool: input.use_private_mempool,
    };

    return this.frontrunCalculator.calculateRisk(frontrunInput);
  }

  /**
   * Calculate backrun risk
   */
  private calculateBackrunRisk(input: VulnerabilityInput): BackrunRiskResult {
    const backrunInput: BackrunRiskInput = {
      amount_in_usd: input.amount_in_usd,
      expected_price_impact_pct: input.expected_price_impact_pct,
      pool_liquidity_usd: input.pool_liquidity_usd,
      pool_volume_24h_usd: input.pool_volume_24h_usd,
      gas_price_gwei: input.gas_price_gwei,
      block_time_seconds: input.block_time_seconds,
      chain_id: input.chain_id,
    };

    return this.backrunCalculator.calculateRisk(backrunInput);
  }

  /**
   * Calculate confidence score (0-100)
   */
  private calculateConfidence(input: VulnerabilityInput): number {
    let confidence = 0;

    // Pool data available
    if (input.pool_liquidity_usd > 0 && input.pool_volume_24h_usd > 0) {
      confidence += this.CONFIDENCE_FACTORS.has_pool_data;
    }

    // Network data available
    if (input.gas_price_gwei > 0 && input.network_avg_gas_price_gwei > 0) {
      confidence += this.CONFIDENCE_FACTORS.has_network_data;
    }

    // Price impact calculated
    if (input.expected_price_impact_pct >= 0) {
      confidence += this.CONFIDENCE_FACTORS.has_price_impact;
    }

    // Mempool data available
    if (input.mempool_pending_txs > 0) {
      confidence += this.CONFIDENCE_FACTORS.has_mempool_data;
    }

    // Data freshness (assume fresh for now)
    confidence += this.CONFIDENCE_FACTORS.data_freshness;

    return Math.min(100, confidence);
  }

  /**
   * Determine risk category from overall score
   */
  private getRiskCategory(score: number): 'low' | 'medium' | 'high' | 'critical' {
    if (score < 30) return 'low';
    if (score < 60) return 'medium';
    if (score < 80) return 'high';
    return 'critical';
  }

  /**
   * Generate recommendations
   */
  private generateRecommendations(
    overallScore: number,
    sandwich: SandwichRiskResult,
    frontrun: FrontrunRiskResult,
    backrun: BackrunRiskResult
  ): string[] {
    const recommendations: string[] = [];

    // Critical risk recommendations
    if (overallScore >= 80) {
      recommendations.push('CRITICAL: Consider canceling this transaction');
      recommendations.push('Use private mempool (Flashbots, Eden Network)');
    }

    // High risk recommendations
    if (overallScore >= 60) {
      if (sandwich.overall_risk >= 60) {
        recommendations.push('Reduce slippage tolerance to minimum acceptable level');
        recommendations.push('Split transaction into smaller chunks');
      }
      if (frontrun.overall_risk >= 60) {
        recommendations.push('Lower gas price to reduce frontrun attractiveness');
        recommendations.push('Use MEV-protection RPC endpoint');
      }
      if (backrun.overall_risk >= 60) {
        recommendations.push('Use higher liquidity pools to reduce price impact');
      }
    }

    // Medium risk recommendations
    if (overallScore >= 30 && overallScore < 60) {
      recommendations.push('Monitor transaction closely after submission');
      recommendations.push('Consider using MEV-protection tools');
    }

    // Low risk
    if (overallScore < 30) {
      recommendations.push('Transaction appears safe to proceed');
    }

    return recommendations;
  }

  /**
   * Generate human-readable explanation
   */
  private generateExplanation(
    overallScore: number,
    riskCategory: string,
    sandwich: SandwichRiskResult,
    frontrun: FrontrunRiskResult,
    backrun: BackrunRiskResult
  ): string {
    const parts: string[] = [];

    // Overall assessment
    parts.push(`Transaction vulnerability: ${riskCategory.toUpperCase()} (${Math.round(overallScore)}/100)`);

    // Risk breakdown
    parts.push(`Risk breakdown: Sandwich ${Math.round(sandwich.overall_risk)}%, Frontrun ${Math.round(frontrun.overall_risk)}%, Backrun ${Math.round(backrun.overall_risk)}%`);

    // Dominant risk type
    const risks = [
      { type: 'sandwich', score: sandwich.overall_risk },
      { type: 'frontrun', score: frontrun.overall_risk },
      { type: 'backrun', score: backrun.overall_risk },
    ];
    const dominantRisk = risks.reduce((max, r) => r.score > max.score ? r : max);
    
    if (dominantRisk.score >= 60) {
      parts.push(`Primary concern: ${dominantRisk.type} attacks`);
    }

    return parts.join('. ');
  }
}

// ============================================================================
// Export singleton instance
// ============================================================================

export const vulnerabilityScorer = VulnerabilityScorer.getInstance();

